### **day01**

#### **变量的定义方式**

 1、先定义，后赋值

​			**var a**;//var（定义）了一个变量，取名叫a

​			**a = 100;**//赋值，和数学的=不一样，它是把=右边的值（数据）存储到=左边的变量（容器）当中

console.log函数作用就是用来打印数据的，如果是变量，会从变量当中拿到数据打印

2、定义的同时赋值,和第一种本质是一样的

​			**var b = 200;**

​			**console.log(b);**

3、特殊，不带var也可以定义一个变量

​			**c;**  //这样写是错的，因为c当中去获取值得时候，c是没有定义的，没有定义去使用就会报错

​			**c = 300;**//如果不带var去定义变量，那么这个变量必须赋值，不赋值就报错；

注意：带var定义的变量和不带var定义的变量，目前可以理解是一样的，但是他们是有区别的

​			//所以，我们以后定义变量的时候，都带var

#### **变量命名规范**

变量名字要符合标识符规则

​			1、变量名由 数字 字母 下划线 以及$组成

​			2、变量名不能由数字开头

​			3、不能和关键字及保留字同名

注意：变量严格区分大小写   A 和 a 不一样

​	  变量以后我们要见名思意 ，定义一个变量存储人名  var personName;

​	  特别注意，变量禁止写拼音，不会的单词，去查，也不能写拼音

变量名字的写法一般有三种

​			1、**大驼峰写法**：

​			**var PersonName;**   所有的单词首字母都大写，但是我们前端用的比较少，也会用（特定情况）

​			2、**小驼峰写法：**

​			**var personName;**   只有第一个单词的首字母小写，其余单词首字母大写，前端主打用法

​			3、**下划线写法：**

​			**var person_name;**  这个写法，我们用的比较少，后端用的比较多

**交换两个变量的值；(整数)**

```js
var a = 100;

var b = 200;

var c;

c=a;

a=b;

b=c;
```

#### **基本数据类型**

**Number** 		**数字**

**String**		**用引号包含的东西就是字符串，单双引号都可以,其实就是文本内容**

**boolean** 		**true false**

**undefined**	**定义变量不赋值，这个变量的值就是undefined,也可以定义变量值是undefined**

**null**			**定义变量赋值为null，经常用来初始化一个对象或者删除一个对象去用**

#### **基本数据判断typeof**

```js
Number** 		**'number'**

**String**		**'string'**

**boolean** 		**'boolean'**

**undefined**	**'undefined'**

**null**			**'objcet'
```

**typeof后面一个值，返回的结果最终是这个值得类型名的小写字符串形式**

​			**但是null这个值特殊：**

​			**1、null返回的是object  由于设计缺陷造成的**

​			**2、null本来就是在初始化对象和删除对象才要使用，归为object**

#### **算术运算符和表达式**   

**1、  +  -  \*  /(拿商除不尽算小数)    %（求余数，除不尽拿余数）**

用来求余数的

​			//**%** 作用比较大，三个场合用的比较多

​			//1、可以判断一个数能否被另一个数整除（两个数求余，余数为0一定能整除）

​			//2、可以求一个数字，各个位上的数

​			// 678       百位  678 / 100 ==> 6.78  ==>(取整) ==》6

​			//       十位  678 /10 % 10  === > (取整)7.8

​			//       个位  678 % 10  ===>8

**3、可以求一个范围内的数**

​			**//任何的一个数对5求余，余数一定落在 0-4范围之内**

​			**//任何的一个数对100求余，余数一定落在 0-99范围之内**

#### **自增自减运算符**

**1、 ++在后， 先赋值（先把变量a的值，赋值给表达式a++）后++(然后偷摸滴让变量a加1)**

**2、 ++在前， 先++（先让变量a的值加1） 后赋值（然后再把变量的值赋值给表达式++a）;**

### **day02**

#### **赋值运算和表达式**

= 和数学里面的= 不同  数学里的=有相等的意思，但是**js=**就是**赋值**的意思

= 它是把=右侧的值赋值给=左侧的变量（右侧一定是有值的东西 100  a  a+b）

= 的左侧现在 只能是**变量**，后期=左侧还可以是对象的**属性**

复合赋值运算符

​			 **+=  -=  \*=  /=  %=**

**a += b****;完全等价于**  **a = a + b;**

#### **条件运算符和条件表达式**

\> 大于     < 小于 	>=大于或等于  <= 小于或等于 	

==相等  != 不相等  		===全等于    !==不全等于

任何运算符其实都是为了去探索这个运算符组成的表达式的值；

​			条件表达式最终的结果一定是布尔值；******

#### **逻辑运算符和表达式**

逻辑运算符条件表达式：

 &&与（并且）	一假则假

  **||**或（或者）	   一真则真

  ! 非（取反）	  非真即假，非假即真

非条件表达式：

 &&与（并且）前面的值如果为真，则取后面的值，作为整个表达式的值；

​		     	前面的值如果为假，则取前面的值，作为整个表达式的值，后面的东西不执行

  **||**或（或者）	 前面的值如果为真，则取前面的值，作为整个表达式的值，后面的东西不执行

​			前面的值如果为假，则取后面的值，作为整个表达式的值

  ! 非（取反）	以后碰到它，首先感叹号要先运算，其次感叹号要求它的后面必须是一个布尔值，

​			不是布尔值，先转化为布尔值，最后再取反

#### **三目运算符和表达式**

只要出现三目运算符或者问号冒号表达式  就是**?:**

先看问号？前面的值为真，则取前面的值作为整个表达式的值，后面的不执行：

​	 	前面的值，值为假，后面的值作为整个表达式的值，前面的不执行；

#### **数据类型强制转换：**（显示转换）

数据的强制类型转换  其实就是想把数据转化为我们想要的数据类型

**Number()    String()     Boolean()**

Number()**数字类型转换**

 **字符串转数字：1、整体去看，如果是一个数字（****前后有空白无所谓，中间不行****），那么就转化为这个数字**

​			  **2、整体去看，如果不是数字，那么转化为****NaN**

​			  **3、****空串****和****空白串****转化为****0**

 **布尔值转数字   true就是1  false就是0**

 **undefined****转数字  出来就是****NaN**

 **null** **转数字 出来就是****0**

String() **任何的数据转字符串，直接加引号**

Boolean()**数据转化布尔值**	

**数字转布尔： 除了0和NaN是false以外，其余都是true**

**字符串转布尔:非空即为真(除了空字符串是false以外,其余都是true)**

**undefined和null转布尔值都是false**

#### **数据类型隐示转换**

**一、数据之间的运算和比较**

**1、先看是不是 +法运算**

**2、如果是 + 法运算，看两边有没有字符串，如果有就是拼接字符串**	

**3、如果不是 + 法，看看是不是比较大小（> < >= <=）**

**4、如果是比较大小，看看两边是否同时是字符串，如果同时是字符串，比较的是字符串的Unicode码**

**5、其余情况，所有的数据全部转数字**

**二、数据之间的判等**

​	**1、先看两边是不是同种数据类型，如果是直接看两边一样不一样，一样就相等，不一样就不等，**

​	**2、如果是不同的数据类型，那么需要将两边同时转数字，然后再去判等**

​	**3、特殊情况：如果碰到了null有特殊情况发生**

​					**null 和 0 不相等** 

​					**null 和 '' 不相等**

​					**null 和 false 不相等**

​					**null 和 undefined 相等**

**三、NaN的总结：一句话  NaN 六亲不认**

​		**NaN和任意的数运算的结果都是NaN，(除字符串以外，拼接字符串)**

​		**NaN和任意的数比较的结果都是false**

​		**NaN和任意的数判等的结果都是不相等（包括它自己）**

**数据类型手动转换**

**数据类型的手动转换，其实本质上是从字符串当中去提取数字（和数据的强制转化隐式转换不一样）**

**如果给的不是字符串，那么会转化为字符串，然后再提取**

**parseInt()   从字符串当中提取整数**  

**parseFloat() 从字符串当中提取小数**

**两个方法要求字符串中数字字符必须在前面，才能提**

**列、****var str = 'audaiusd123';//NaN**  

​	**str = '     123sjygakdj';//123**

​	**str = '     12.34uaysgda';//12.34**

​	**str = '     12.34.56sdasdggada'//12.34**

### **day03**

#### **if单分支**

语法： if(转化布尔值){    代码块 } 

执行过程：1、计算小括号当中的值

​		 2、把小括号当中的值转化为布尔值

​		 3、根据布尔值的真假决定是否执行花括号当中的代码块（如果是真就执行，如果是假就不执行）

**注意**：无论if当中代码块是否执行，if以下的语句都是要去执行的

#### **if双分支**

 if(){ 代码块 }else{ 代码块 } 

执行过程:1、计算if小括号当中的值

​	    	2、把小括号当中的值转化为布尔值

​		3、根据小括号当中的值得真假决定是走哪一个花括号当中代码

​		如果是真，就走if花括号当中的代码块，如果是假就走else花括号当中的代码

​			

理解： 双分支其实和单分支 都可以理解为双分支，单分支只是在处理条件为真的时候

双分支其实是单分支的增强版，条件为真和假都要处理，只是处理的代码不同

**if多分支**

```js
//语法 /*        * 
if(){     
	}else if(){     
    }else{           
    } 
```

执行过程:1、先计算if后()里面的值

​		2、把if后()里面的值转化为布尔值

​		3、如果if后（）的值为真，就执行if花括号里面的代码

​		4、如果if后（）的值为假，就接着判断下一个if后（）的值，（判断过程同上）

​		5、如果上面所有的if后()里面的值，都为假，最后执行else花括号里面的代码	

**switch多分支**

switch(全等){    case 值:代表标号用来做全等用的    	代码块    	break;在switch语句当中用来跳出switch语句    case 值:    	代码块    	break;    default:    	代码块    	break; } 

执行过程:1、计算switch后面（）的值

​		2、切记这个值不会做任何转化

​		3、无论这个值是什么都会进入到花括号内部

​		4、拿这个值去一一对比 case标号后面的值（对比的时候使用的是全等去做对比的）

​		5、如果对比成功（全等），那么就会执行相应case标号下面的代码块

​		6、如果所有的标号都不全等，最终会执行default标号下面的代码块

理解：switch...case是if多分支的一个变种，为了解决if分支比较多的时候，代码可读性不强

​			//而出现的；

#### **循环基础**

循环有三种：  for循环   while循环   do...while循环

语法：for(一般都是初始化表达式;一般都是条件表达式;一般都是自增自减表达式){ //				代码块  // 循环体 } 

执行过程

 首次执行   

​			先执行初始化表达式

​			再执行条件表达式

​			条件表达式为真，执行循环体（如果为假，循环结束）

​			最后执行自增自减表达式

​	 非首次执行

  先执行条件表达式

  再执行循环体

 			再执行自增自减表达式

for(var i = 0; i < 100; i++){ 			console.log('i love you~ baby~'); 		} 循环变量 i 控制着循环的次数，并且循环变量每一次循环的值是不一样的； 		//注意：条件表达式才是循环结束的标志：每一次循环都要去执行条件表达式 		//条件表达式为真，继续执行循环，如果条件表达式为假，立即结束循环； 

循环练习

```js
打印1-100之间的整数 		
//启发：以后如果要拿到连续的一堆数，for循环 //			
for(var i = 1; i <= 100; i++){ 
    //				console.log(i); //			
} //			
打印1-100之间的偶数(严谨) //			for(var i = 1; i <= 100; i++){ //				if(i % 2 == 0){ //					console.log(i); //				} //			} //			计算1到100的和 		//累加器 //			var sum = 0; //			for(var i = 1; i <= 100; i++){ //				sum += i;// sum = sum + i //			} //			console.log(sum);  //			计算1-100之间所有偶数的和 		var sum = 0; 		for(var i = 1; i <= 100; i++){ 			if(i % 2 == 0){ 				sum += i;// sum = sum + i 			} 		} 		console.log(sum);   //一个循环当中又有另外一个循环 		//循环嵌套： 外部循环执行一次，内部循环执行一轮 		//循环嵌套不应该嵌套层次太多，如果太多，效率很低（时间复杂度比较大） //			for(var i = 0; i < 100; i++){ //				for(var j = 0; j < 100; j++){ //					for(var k = 0; k < 100; k++){ //						console.log('i love you~ zhao li ying~'); //					} //				} //			} 		 		//1、打印矩形 		//***** 		//***** 		//***** 		//***** 		//***** 		//规定每次只能打印一颗* 		//外部循环控制行，内部循环控制列 //			for(var i = 0; i < 5; i++){ //				//外部循环控制行 //				for(var j = 0; j < 5; j++){ //					//内曾循环控制列（就是真正打印*） ////					console.log('*'); //					document.write('*'); //				} //				document.write('<br>'); //			} 		 		//2、打印直角三角形 		//外部循环控制行，内部循环控制列 		//* 		//** 		//*** 		//**** 		//***** 		 		for(var i = 0; i < 5; i++){ 			 			for(var j = 0; j < i + 1; j++){ 				//在打印对应行的* 				document.write('*'); 			} 			document.write('<br>'); 			 		} 		 		 		//3、打印99乘法口诀表 		//外部循环控制行，内部循环控制列 //			1*1=1 //			1*2=2 2*2=4 //			1*3=3 2*3=6 3*3=9 		 		 		for(var i = 1;i <= 9; i++){ 			for(var j = 1; j < i+1; j++){ 				 //					1*1=1 				document.write(j + '*' + i + '=' + i * j + '   '); 			} 			document.write('<br>'); 		} 		 
```

### day04

**for循环二班情况**

for循环小括号内部表达式是可以为空的

二般写法：效率没有上面的高；

var i = 0; for(;i < 100;){    console.log('i love you~');    i++; } 

for循环的死循环

​			//for循环小括号里面的第二个表达式决定着循环什么时候结束（条件为假）

​			//如果第二个条件表达式值永远为真，那么就是死循环

for(var i = 0; true; i++){    console.log('i love you~'); } //for循环死循环写法 for(;true;);//死循环 for(;;);//死循环，是对上面的简写 

**while循环和do...while循环**

while循环其实是由for循环的二般情况演变而来的

while循环语法是由for循环演变而来的

​			//能用for循环的一定能用while循环，能用while循环的也一定能用for循环

​			//不过他们在不同的场合下，写的时候难易程度不一样

var i = 100; while(i < 100){    console.log('i love you~');    i++; } console.log(i); 

do...while循环 又是由while循环演变而来

var i = 100; do{    console.log('i love you~');    i++; }while(i < 100); console.log(i); 

/while循环和do...while循环的区别（简答）

​			//while循环，先判断条件，如果条件为真执行循环体，如果条件为假，结束循环；

​			//如果一开始条件就为假，那么循环体一次都不执行

​			//do...while，先执行一遍循环体，然后再判断条件，他如果条件为真，继续执行循环体，如果条件为假

​			//结束循环； 如果一开始条件就为假，那么循环体也要执行一次。它至少会执行一次循环体；

​			

​			//while和do...while最大区别就是一开始条件不满足

​			//如果一开始条件是满足的，他们最后效果是一样的

​			

//while循环的死循环

​			//for(;;);  for循环的死循环

​			//while(true);while循环的死循环

**continue和break关键字的作用**

continue关键字的作用（循环当中才会出现）

结束本次循环，返回从下一次开始

break关键字的作用：1、switch语句用来跳出switch 

​				 2、循环当中用来跳出离它最近的一层循环（包含它的）

for(var i = 1; i <= 100; i++){        if(!(i % 3 == 0 || i % 7 == 0)){        //i % 3 == 0 || i % 7 == 0为假 if会执行        continue;//结束本次循环，返回从下一次开始（返回到i++,continue以下所有的代码不再执行）                // break;//立即跳出循环，而且跳出包含它的一层循环        }        console.log(i); } 

**for循环强化练习**

//			1、计算100的阶乘 1*2....*100   100!      1-100的和  //			var pride = 1; //			for(var i = 1; i <= 100; i++){ //				pride *= i; //			} //			console.log(pride); //			console.log(Number.MAX_VALUE);//js能表示的最大数字 //			console.log(Number.MIN_VALUE);//js能表示的最小数字 //			console.log(1/0);//Infinity //			console.log(-1/0);//-Infinity //			console.log(0/0);//NaN //			console.log(1%0);//NaN 		 //			2、求1!+2!+3!+...+20!的值 		//  4的阶乘 = 3的阶乘 * 4    		//  100的阶乘 = 99的阶乘 * 100 		 //			var sum = 0; //			var pride = 1; //			for(var i = 1; i <= 20; i++){ //				pride *= i;//pride = pride * i    //				sum += pride; //			} //			console.log(sum); //			3、打印三位数位上有3或者7的数字   //			for(var i = 100; i <= 999; i++){ ////				678/100  6.78 ////				第一步求出每个位上的数字 //				var b = parseInt(i / 100);  //				var s = parseInt(i / 10 % 10); //				var g = i % 10; ////				第二步:判断求出的每个位上数字是否有3或者7 //				if(b == 3 || b == 7 || s == 3 || s == 7 || g == 3 || g == 7){ //					console.log(i); //				} //			} //			4、求100-999之间的水仙花数。   三位数每个位上的数字立方之和等于这个三位数 //				abc = a*a*a + b*b*b + c*c*c   abc这个数就是水仙花数 //			for(var i = 100; i <= 999; i++){ ////				678/100  6.78 ////				第一步求出每个位上的数字 //				var b = parseInt(i / 100);  //				var s = parseInt(i / 10 % 10); //				var g = i % 10; ////				第二步:判断求出的每个位上数字是否有3或者7 //				if(b*b*b + s*s*s + g*g*g === i){ //					console.log(i); //				} //			}  //			5、输出1-100之间所有的素数（质数）（只能被1和自身整除的数,但是1不是质数）\ 		//双层循环 		//1、标志位法：思想 		//外层循环控制被除数 		//内层循环控制除数 //			var flag = true; //标志位方法后期用的很多 //			for(var i = 1; i <= 100; i++){ ////				flag = true; //				//外层就是用来拿被除数的 //				//8 7 //				for(var j = 2; j < i; j++){ //					//内层是用外层拿到的被除数 去 做除法用的 //					if(i % j == 0){ //						//2-7之间有一个能整除 //						flag = false; //						break; //					} //				} //				//break跳出来的地方在这（代表不是质数） //				//老老实实执行完for循环最终位置也在这（代表是质数） //				//事来了，怎么区分是质数还是不是质数 //				if(flag && i!=1){ //					console.log(i); //				} //				flag = true; //重置标志位； //			} 		 		 			//2、计数器法： 思想 		var n = 0; 		for(var i = 1; i <= 100; i++){ 			//外层循环还是在拿被除数 			for(var j = 1; j <= i; j++){ 				//内层循环拿除数 				if(i % j == 0){ 					n++; 				} 			} 			 			if(n == 2){ 				console.log(i); 			} 			 			n = 0; 		} 		 		 		 //			6、完成一个等腰三角形的打印 //			 //		     	  *       //		     	 *** //		        ***** //		       ******* //		      ********* //		     *********** //		    *************      		//外层循环控制行，内层循环控制列 		for(var i = 0; i < 7; i++){ 			//外部循环控制的是7行 			 			//先打印每一行当中的空格并且不换行 			for(var j = 0; j < 6 - i; j++){ 				//打印空格的 				document.write(' '); 			} 			 			//再打印每一行当中的*，完事之后换行 			 			for(var k = 0; k < 2 * i + 1; j++){ 				//打印星花的 				document.write('*'); 			} 			 			document.write('<br>'); 			 		} 

**数组基础**

数组是一种数据，它属于对象数据类型

数组概念：同种或者不同种类型数据的有序集合

数组就是用来让我们一次性的存储多个数据用的（这些数据可以是相同类型，也可以是不同类型）

数组的定义：

数组的定义：        //1、数组的字面量定义：        var arr = [];//定义了一个空数组        var arr1 = [1,2,3,'zhaoliying',4];//定义了一个数组里面有5个元素,可以不同类型        //			//注意：数组虽然可以存储不同数据类型的数据，但是一般都是存储相同类型的；        var arr2 = [1,2,3];//定义了一个数组里面有3个元素,相同类型 		        2、构造函数定义数组        var arr3 = new Array();//相当于定义了一个空数组        var arr4 = new Array(1,2,3);//相当于定义了一个数组，里面有3个元素1，2，3        var arr5 = new Array('zhaoliying');//相当于定义了一个数组，里面存储了一个元素'zhaoliying';    	         坑var arr6 = new Array(4);//相当于定义了一个数组，里面不是一个元素，4代表的是数组的长度（4个元素） 		 //数组的定义，以后我们用的比较多的就是字面量定义，构造函数定义的方式用的比较少，但是得会； //其实字面量定义数组  是 构造函数定义数组的简写方式，也就是说数组本质都是由构造函数定义出来的； 		 

数组两个重要概念：

定义一个数组定义好之后会自动出现两个概念：长度和索引（下标）

数组的长度，定义好数组以后会自动出现，它可以修改，对数组进行增删操作

数组的索引（下标）很重要，知道了索引，那么我们就可以操作数组里面对应这个索引的元素

var arr = [100,2,300,4,5]; arr[3] = 400; //读写数据：读：代表只是再获取数据但是不会动原本的数据 （查） //         写：代表把原来的数据动了（增  删   改） arr[4] = 500; 

**数组的长度 = 数组的最大下标  + 1；**

数组的长度可以在数组的末尾去修改数组（添加和删除）

如果要对数组添加一个元素

通过数组长度给数组添加元素

var arr = [100,2,300,4,5]; console.log(arr[5]);//undefined console.log(arr[100]);//undefined arr[arr.length] = 600;//通过数组长度给数组添加元素，代表从数组末尾加一个元素，数组的长度会自动改变 arr.length-=2;通过数组长度给数组删除元素 

**数组案例**

1、数组的遍历（打印数组当中所有的元素值） 		//循环变量的值对应的就是数组的下标 		 //			for(var i = 1; i <= 100; i++){ //				console.log(i); //			} 		//从前往后去遍历数组 		var arr = [100,200,300,400,500]; //			for(var i = 0; i < arr.length; i++){ //				//i的取值，刚好是0 - 4 对应的刚好就是数组的下标 //				console.log(arr[i]); //			} 		 //			//从后往前去遍历数组 //			for(var i = arr.length - 1; i >= 0; i--){ //				console.log(arr[i]); //			} 2、数组求和 //			var sum = 0; //			for(var i = 0; i < arr.length; i++){ //				sum += arr[i]; //			} //			console.log(sum); 3、求数组最大值，最小值，平均值 //			var arr = [23,44,10,88,66]; //			var max = arr[0];//100 //			var min = arr[0]; //			var sum = 0; //			for(var i = 0; i < arr.length; i++){ //				if(max < arr[i]){ //					//用来判断最大值 //					max = arr[i]; //				} //				 //				if(min > arr[i]){ ////					判断最小值 //					min = arr[i]; //				} //				//求和 //				sum += arr[i]; //			} //			console.log(max,min,sum/arr.length); 4、合并数组（在新数组当中合并 / 在原数组当中合并） 		var arr1 = [1,2,3,4,5]; 		var arr2 = [6,7,8,9,10]; 		 //1、把两个数组的值统一放到一个新数组当中，打印新数组 		var newArr = []; //			//遍历第一个数组里面的每个值，一一放到newArr里面 		for(var i = 0; i < arr1.length; i++){ 			newArr[newArr.length] = arr1[i]; //2 //			  i = 0  	newArr[0] = 1;   newArr长度会自动变为1 		//i = 1     newArr[1] = 2;   newArr长度会自动变为2 		} 		//遍历第二个数组里面的每个值，一一放到newArr里面 		for(var i = 0; i < arr2.length; i++){ 			newArr[newArr.length] = arr2[i]; //			  i = 0  	newArr[0] = 1;   newArr长度会自动变为1 		//i = 1     newArr[1] = 2;   newArr长度会自动变为2 		} 		console.log(newArr); 		console.log(arr1); 		console.log(arr2); 		 2、在任意的一个数组后面，放上另外一个数组的元素 		 		for(var i = 0; i < arr1.length; i++){ 			arr2[arr2.length] = arr1[i]; 		} 		console.log(arr2); 

**数组强化练习**

1、找出数组中的所有偶数打印，奇数生成新数组    var arr = [1,2,3,4,5,6,7,8,9,10];//定义数组    var newArr = [];    for(var i = 0; i < arr.length; i++){        if(arr[i] % 2 == 0){            //偶数    	console.log(arr[i]);     }else{         newArr[newArr.length] = arr[i];        }	    } //    arr[i] % 2 == 0?console.log(arr[i]):newArr[newArr.length] = arr[i];          console.log(newArr); 2、数组去重(都是不动原来的数组，去重后是一个新数组)    var arr = [1,2,3,4,1,2,1,1,2,5];    var newArr = [];//用来保存去重后的结果，原数组不会动 //双层for循环   外部循环控制从数组里面拿数，内层循环控制从新数组当中拿数比较    var flag = true;    for(var i = 0; i < arr.length; i++){  //外部循环从老数组里面取值  arr[0] arr[1]        for(var j = 0; j < newArr.length; j++){          //  /内部循环从新数组当中取值            if(arr[i] == newArr[j]){                flag = false;    		break; 	} 		} //break跳出来的地方，代表新数组当中已经有当前这个值了 //老老实实执行完内部for循环，到这个位置，代表新数组当中没有当前这个值；            if(flag){ 		newArr[newArr.length] = arr[i];   	}            flag = true; 	} //			 //			console.log(newArr); //			console.log(arr); 		 3、反转数组*******(倒序排列) 		var arr = [1,2,3,4,5];//  [5,4,3,2,1] 		//3-1  新数组翻转 //			for(var i = arr.length - 1; i >= 0; i--){ //			var newArr = []; //				newArr[newArr.length] = arr[i]; //			} //			console.log(newArr); 3-2 原数组翻转 //			for(var i = 0; i < arr.length/2;i++){ //				//1、除以2不能省，省了好不容易换的，又被换回去 //				//2、这个题的思想：  就是交换两个变量的值 //				var temp = arr[i]; //				arr[i] = arr[arr.length - 1 - i]; //				arr[arr.length - 1 - i] = temp; //			} //			console.log(arr); 		 4、冒泡排序******************************** 		 //			var arr = [24,12,36,88,30];//; //			//双层for循环 //			//外层循环控制轮 //			//冒泡排序  i j不能从1开始，因为可能还要用作数组的下标 //			for(var i = 0; i < arr.length - 1; i++){ //				//外部循环控制轮 //				for(var j = 0; j < arr.length - 1 - i;j++){ //					//内部循环控制的是每一轮交换的次数 //					//同时内部循环变量j,也代表着每次交换取的元素的下标 //					if(arr[j] > arr[j + 1]){//>就是从小到大排序（升序） <就是从大到小排序（降序） //						var temp = arr[j]; //						arr[j] = arr[j+1]; //						arr[j+1] = temp; //					} //				} //				 //			} //			 //			console.log(arr); 		 5、二维数组(了解) 		//多维数组 		//一维数组   [24,12,36,88,30] 		//二维数组   一维数组当中的元素，又是一个数组  [[1,2],[3,4],[5,6]] 		//三维数组   		//四维数组 		//五维数组 		 		var arr = [1,2,3,4]; 		console.log(arr[2]);//3 		//二维 		var arrTwo = [[1,2],[2,3],[4,5]]; 		console.log(arrTwo[2][0]);//4 		 

**day05**

**函数定义**

函数的定义2种

//函数声明定义 function printTriangle(){    //功能代码块    函数体 } //函数表达式定义 var printTriangle = function(){    //功能代码块    函数体 } //函数声明定义方式和函数表达式的定义方式，本质上都是定义了一个变量，内部存储的是函数数据； 		//都可以理解为   //			var printTriangle = function(){ //				//功能代码块    函数体 //			} 

**函数三要素**

函数定义的时候包含3要素：

​			//1、功能: 功能其实就是函数名字，函数名字要见名思意，看到函数名就知道这个函数是干嘛的

​			//2、参数：函数定义小括号里面的东西，代表的是函数定义的参数，叫做形式参数，简称形参；

​			//形参有的有，有的没有。如果有，形参的本质是在函数定义内部定义的变量;

​			//3、返回值: 函数定义函数体内部return 关键字后面的值，代表的是返回值;

​			//返回值有的有，有的没有。return 后面一定是一个值（100，变量，表达式）;

​			//return 关键字如果没有，函数默认也是有返回值，返回的是undefined;

​			//return 关键字有两个作用：1、返回值、2、函数内部代码执行到return立即结束，以下代码不再执行

​			

​			//函数调用的时候也包含3要素：

​			

//			fn(10,20)；

​			//1、功能: 函数调用的名字必须和函数定义的名字完全一致，才能调用，否则报错

​			//2、参数: 函数调用的小括号里面是函数调用时候传递的参数，叫做实际参数，简称实参

​			//实参的本质一定是值（变量，表达式），函数调用的实参是用来给函数定义的形参赋值的；

​			//3、返回值：函数调用本质是函数调表用达式；表达式就是有值的。函数调用表达式整体的值

​			//就是函数定义内部return返回来值；没有默认就是undefined;

**函数封装**

**函数分类：两种思路**

1、自定义函数和系统函数     alert() 系统函数（小布已经帮你定义好了，你直接使用）

​	函数必须定义才能调用

2、自定义函数按照参数和返回值：

​			// 1)无参无返回值（没有return,返回undefined）

​			// 2)无参有返回值

​			// 3)有参无返回值

​			// 4)有参有返回值（以后大部分函数都是有参也有返回值）

​			

所有的函数，都可以有参数和有返回值，只不过参数和返回值看你要不要，不要相当于没用

**函数封装练习**

1、编写求1到n的和函数 //			function add(n){ //				var sum = 0; //				for(var i = 1; i <= n; i++){ //					sum += i; //				} //				return sum; //			} // //			var result = add(50); //			console.log(result); 			//任何语言计算机计算小数是不准确的 //			console.log(0.1+0.2); //			2、编写函数实现求一个数的阶乘 //			function factorial(n){ //				var pride = 1; //				for(var i = 1; i <= n; i++){ //					pride *= i //				} //				return pride; //			} //			console.log(factorial(5)); //			3、编写函数求数组的最大值，最小值 //			function getMaxAndMinOfArray(arr){ //				var max = arr[0],min = arr[0]; //				for(var i = 0; i < arr.length; i++){ //					if(max < arr[i]){ //						max = arr[i]; //					} //					 //					if(min > arr[i]){ //						min = arr[i]; //					} //				} //				return [max,min]    //return只能return一个值，要想返回多个，数组 //			} //			 //			 //			//直接传值 ////			var result = getMaxAndMinOfArray([1,3,2,8,5]); ////			console.log(result[0],result[1]); //			 //			var arr = [1,3,2,8,5]; //			var result = getMaxAndMinOfArray(arr); //			console.log(result[0],result[1]); //			4、封装函数加工数组，每一项加10输出 		 		function productArray(arr){ //				var arr = [1,2,3,4,5];形参arr相当于干了这件事 			for(var i = 0; i < arr.length; i++){ //					console.log(arr[i] + 10);//数组的值不会变化 				console.log(arr[i]= arr[i] + 10);//修改了数组的值 			} 		} 		 		var arr = [1,2,3,4,5]; 		productArray(arr); 		 		 //			封装函数实现打印1到N的质数; //			封装函数实现对数组进行排序； //			封装函数实现对数组翻转 //			封装函数实现对数组去重					 

**作用域：**

​	概念：变量起作用的区域和范围就叫作用域

​	作用域作用：隔离变量

​	在ES5当中，有两个作用域：全局作用域和局部作用域（函数作用域）

​	以函数为界，函数的内部被称作局部作用域，函数的外部被称作全局作用域

​	作用域在函数定义完成就已经确定好了（代码写完作用域就确定好了）

​	作用域：看不见摸不着，是一个抽象的概念

​	

//全局变量和局部变量

​	//定义在全局作用域当中的变量叫做全局变量

​	//定义在局部作用域当中的变量叫做局部变量

​			

​	//全局变量和局部变量

​	//全局变量整个程序都可以看到，都可以使用；

​	//局部变量只有局部可以看到，可以使用；

​	//全局变量和局部变量同名，各自使用各自的；

内外全局变量和局部变量都带var

​	默认全局使用全局，局部使用局部，但是局部没有可以使用全局，全局没有不能使用局部，会报错；

当函数内部出现变量不带var

​			//1、先看函数内部有没有定义var这个变量，如果有就是局部变量

​			//2、如果函数内部没有定义var这个变量，找形参，形参如果有，当做局部变量处理

​			//3、如果形参也没有，那么找全局，全局有，那么就是在操作全局变量

​			//4、如果全局也没有，那么相当于在全局定义了一个变量（全局变量）

​			var a = 100;//全局 		 		function fn(a){ 			a = a + 10;//a是局部 			console.log(a); 		} 		 		fn(a); 		 		console.log(a); 

**//作用域链：**

​			//和作用域完全不是一个东西

​			//作用域链描述的是程序查找变量的过程

​			//首先在自己的作用域当中去查找，如果查找不到，去到上级作用域去查找，查到就用

​			//查不到继续往上查找，直到找到真正的全局，找到就用，找不到报错（引用错误，这个变量没定义）

​			

​			//作用域链的顶端 一定是全局；

​			//后期是可作用域链是真实存在的，我们以看到的

​			//作用域是函数定义好就存在的，而作用域链是函数调用的时候才有的；

//函数定义时候作用域就定死了，调用的时候作用域链顺着作用域去查找，函数的作用域和调用没关系

​                    var a = 0; 		function fn1(){ //				var a = 1; 			function fn2(){ //					var a = 2; 				function fn3(){ //						var a = 3 					console.log(a);//3 				} 				fn3(); 			} 			fn2(); 		} 		 		fn1(); 

​                    var num = 10; 		function fun() {   			var num = 20;   				   			fun2(); 		} 		 		function fun2() { 			console.log(num);//10 		} 		fun(); 

**预解析**

//预解析：预解释 还叫代码提升，在程序开始执行后，代码执行之前，会发生预解析

预解析会发生在  函数声明定义的函数 和 带var的变量身上

代码开始执行之前会预解析：预解析分为两步：

​			//1、先预解析 函数声明定义的函数，函数重名会发生覆盖，(上面的会被忽略)

​			//2、再预解析 带var的变量（预解析不会带着值，只会提升变量），变量名重复会忽略；(后面的会被忽略)

/注意：函数如果是函数表达式定义的，当做带var的变量去对待

​			变量如果是不带var定义的，不会发生预解析

**内存的结构区分**

内存其实是分很多区的

​			//内存当中比较重要的两个区    栈和堆    栈内存和堆堆内存

​			//c语言  java 他们在运行的时候 栈内存和堆内存都要使用

​			//js它在运行的时候，只使用堆内存

​			//栈内存和堆内存 其实说的是数据存储的一种数据结构

​			//栈内存：比较小  存取速度比较快   计算机自动帮我们分配  不需要程序员操心，它是有顺序的（先进后出FILO）

​			//堆内存：比较大   存取速度比较慢  程序员要手动分配手动释放  数据结构使用的链表做的，可以任意位置随意更改

​			

​			堆内存:  js是使用的堆内存，堆内存当中又分成两个结构，我们叫栈结构和堆结构

​			//今后我们讨论的就是堆内存当中栈结构和堆结构		

**程序执行的内存展现**

**//1、程序执行开始  会碰到全局（必须的），会先创建全局执行环境，压入栈结构当中**

**//2、其实创建全局环境同时，就对全局代码做了预解析**	

基本数据类型和对象数据类型在内存当中的区别

​			//1、基本数据类型和对象数据类型变量都是在栈结构内部

​			//2、基本数据类型的数据是和变量存储在一起

​			//3、对象数据类型的数据是存储在堆结构当中，然后把数据真正堆结构当中的地址放在栈里面的变量里面

​			//4、对象数据切记玩的是地址

​			//5、基本数据玩的就是数据本身

​			

//基本数据类型  a ,b 里面都有自己的10   a改为20   不会影响b的10

​			var a = 10; 		var b = a; 		a = 20; 		console.log(b); 

​			

//对象数据类型   arr1和arr2 存储的是同一份数组数据在堆当中的地址  arr1和arr2操作的是同一份数据

//arr2通过地址修改内部的数据，另外也是被修改后的；一个arr1去查看 

​			var arr1 = [1,2,3]; 		var arr2 = arr1; 		arr2[1] = 22; 		console.log(arr1); 

​			

//对象数据类型   arr1和arr2 存储的是同一份数组数据在堆当中的地址  arr1和arr2操作的是同一份数据

//arr2地址被改变为另外一个数组的地址，不会影响arr1里面开始的地址

​			var arr1 = [1,2,3]; 		var arr2 = arr1; 		arr2 = [1,22,3]; 		console.log(arr1); 

**day07**

**程序执行和多次调用的基本程序**

1、预解析全局代码

2、执行全局代码（从上到下一行一行走）

3、执行全局代码的时候碰到函数调用，首先还是预解析函数内部代码

4、从上到下在函数内部一步一步执行函数内部的代码

5、函数执行完成，死了，返回到全局当中继续执行全局代码

6、直到全局代码完成

1、预解析全局代码

画图

2、执行全局代码（从上到下一行一行走）

​	开辟空间存储变量的值

3、执行全局代码的时候碰到函数调用，首先还是预解析函数内部代码

4、从上到下在函数内部一步一步执行函数内部的代码

5、函数执行完成，死了，返回到全局当中继续执行全局代码

6、直到全局代码完成

**基本数据和对象数据**

//基本数据类型  a ,b 里面都有自己的10   a改为20   不会影响b的10

​			var a = 10; 		var b = a; 		a = 20; 		console.log(b); 

​			

//对象数据类型   arr1和arr2 存储的是同一份数组数据在堆当中的地址  arr1和arr2操作的是同一份数据

//arr2通过地址修改内部的数据，另外一个arr1去查看 也是被修改后的；

​			var arr1 = [1,2,3]; 		var arr2 = arr1; 		arr2[1] = 22; 		console.log(arr1); 

//对象数据类型   arr1和arr2 存储的是同一份数组数据在堆当中的地址  arr1和arr2操作的是同一份数据

//arr2地址被改变为另外一个数组的地址，不会影响arr1里面开始的地址

​			var arr1 = [1,2,3]; 		var arr2 = arr1; 		arr2 = [1,22,3]; 		console.log(arr1);                   var arr1 = []; 		var arr2 = []; 		var arr3 = arr1; 		arr3 = []; 		 		arr3[0] = 12; 		console.log(arr1,arr2,arr3);//[] [] [12] 

​			

**函数IIFE(自调用）**

//		Immediately Invoked Function Expression意为立即调用的函数表达式，也就是说，

//		声明函数的同时立即调用这个函数。

​		//也叫做匿名函数自调用			

//匿名函数调用 //匿名函数自调用，立即调用函数表达式； (function(){ //			 //		})();  最后的括号是调用的小括号，可以用来传实参    function后的小括号是形参小括号 console.log([1,2,3][1]);//如果没有变量存储数组，只能使用一次，                        //没法再去使用原来这个数组的数据 console.log([1,2,3][0]);//拿的是一个新数组的元素，和上面的数组不是一个		 

​	特点：//1、函数定义的同时调用

​		//2、只能调用一次，以后不可能在调用这个函数（如果想调用多次，必须使用有名函数）

​		//3、匿名函数自调用，函数整体不会发生预解析，但是函数内部执行会预解析

​		

​		//在哪用到

​		//1、项目初始化的代码放到匿名函数当中保证执行一次

​		//2、实现框架的封装 jQuery（模块化）

//		(function( window, undefined ) { //			//jQuery的源码 //		})( window );		 

**arguments**

arguments只存在于函数内部,它是一个函数内置的变量,它代表是函数实参伪数组，本质上是一个对象

1、函数的形参可有可无，因为arguments当中可以获取到函数的实参，但是不方便

​	虽然可以不写形参，通过arguments去操作实参，但是最好还是写之前的带形参；

function add(a,b){//形参可有可无,在ES5当中 //				console.log(arguments);//实参伪数组 ////				return a + b; //				return arguments[0] + arguments[1]; //			} //			var a = 10; //			var b = 20; //			console.log(add(a,b,100)); 

2、arguments.length代表实参的个数

//arguments.length可以让函数功能多样化，丰富

//这个函数现在需要有+或者-的功能（加法和减法）

​	//传递3个实参我们就加法

​	//传递2个实参我们就减法

function addOrSub(a,b,c){ //				if(arguments.length === 2){ //					return a - b; //				}else if(arguments.length === 3){ //					return a + b + c; //				} //			} //			 //			console.log(addOrSub(100,20));//减法 //			console.log(addOrSub(1,2,3));//加法 

3/arguments.callee  代表arguments所在的函数本身

function fn(){ 			console.log(arguments); 			console.log(arguments.callee); 		} 		fn(); 

**函数可以但参数传递**

函数本身也就是数据，数组也是数据，基本数据也是数据，都是可以当函数参数去传

​			//函数（对象数据）当参数传递的是函数的地址

​			//函数作用域不关心在哪调用，而关心在哪定义

**回调函数的概念：**

​			//1、函数是我定义的

​			//2、我没有调用

​			//3、最终执行了(可以认为回调函数都是在某一个时刻，系统帮你调用)

​			

​			//1、事件回调

​			//2、定时器回调

​			//3、ajax回调

​			//4、生命周期回调

**函数递归调用**

在一个函数内部执行的时候，又调用（直接或者间接）调用自己

​			//我们就说这个函数是递归调用

​			//函数的递归调用是一把双刃剑，用的好，代码狠简洁，用的不好，造成灾难；

​			//递归调用函数用的不好，会出现内存溢出（内存装不下）

​			

​			

​			//递归要想用的好，必须满足以下两个条件

​			//1、递归必须有一个明显的结束条件

​			//2、递归必须有一个趋近于结束条件的趋势

//递归调用打印10次之后，停止 		//计数器 		var n = 0; 		function fn(){ 			if(n == 10){ 				return; 			} 			console.log('i love you~'); 			n++ 			fn(); 		} 		 		fn(); 		 		 		 		//递归实现求一个数的阶乘 		// n! = (n-1)!*n 		 		function factorial(n){ 			if(n <= 1){ 				return 1; 			} 			 			factorial = 100; 			 //				return factorial(n-1)*n; 			return arguments.callee(n-1)*n;//arguments.callee主要就是递归用 		} 		 		console.log(factorial(5)); 		 		//如果以后碰到很多种方法都可以解决的事情，能不用递归尽量别用 		//因为递归效率狠慢 而且内存占用比较大 		//除非逼不得已再用 

**Objeck实例化对象**

​			//对象是无序键值对的集合

​			//内部由属性和属性值组成

​			//对象的属性，本质上都必须是字符串，但是在前端当中对象的属性引号可有可无

​			//对象的属性名如果不符合标识符规则，那么必须带引号

​			

​			//对象的属性值，可以是任意的数据类型；基本数据和对象数据都可以

​			//对象的属性值如果是一个函数，那么这个属性我们被称作是这个对象的方法；

​			

​			//以后我们也可以说对象是由属性和方法组成的，其实方法是一种特殊的属性；

//无论以下是哪种对象的创建方式，本质上都是通过构造函数创建出来的对象

​			//而且他们创建出来的对象都称作是Object的实例化对象

​			//因为他们创建的这些对象都是由Object 实例化出来的，简称是Object的实例；

​			

​			//Object的实例化对象特点： 

​			//通过Object实例化的对象可以是任何的对象，Object类别不确定，实例化的对象可以任意指定

​			//你给这个对象指定是人就是人，你给这个对象指定是狗那就是狗，就看你填的属性是什么

​			//也就是说通过Object实例化的对象不确切；

1、字面量创建

​            var obj = { 			name:'旺财', 			'age':3, 			"height":100, 			eat:function(){ 				console.log('吃货'); 			}, 			'con-type':1//对象的属性名如果不符合标识符规则，那么必须带引号 		}; 		 		var obj2 = {};//定义一个对象，内部没有任何数据 

//2、构造函数创建

var obj3 = new Object({ 			name:'赵丽颖', 			'age':33, 			"height":165, 			eat:function(){ 				console.log('吃货'); 			}, 			movies:['乘风破浪','青云志'], 			'con-type':1//对象的属性名如果不符合标识符规则，那么必须带引号 		}); 		 		var obj4 = new Object();//定义一个对象，内部没有任何数据 		console.log(obj3);//也是定义了一个对象，它才是定义对象的本质写法，字面量定义是它的渐变写法 		 

3、工厂函数创建

function createObject(name,age,height){ 			var obj = new Object({ 				name:name,//冒号前面是创建对象的属性名，冒号后面代表的是函数的形参变量（取值） 				age:age, 				height:height 			}) 			 			return obj; 		} 		var result = createObject('zhaoliying',33,165); 		console.log(result); 		 		var result1 = createObject('yangmi',34,168); 		console.log(result1); 		 		var result2 = createObject('dilireba',20,168); 		console.log(result2); 

**[  ]语法**

//			增 	obj['height'] = 165;//[]直接操作对象内部属性的时候必须带引号，不带[]内部就是变量。

////			改	obj['name'] = '杨幂';	//对于增和改    有则更改，无则添加

////			删	delete obj['age']; //删除

////			查	console.log(obj['con-type']);//读取obj当中con-type属性的值

​		console.log(obj['eat']);

**/点语法**

​			//增	obj.height = 165;

​			//改	obj.name = '杨幂';

​			//删	delete obj.age;

​			//查console.log(obj.name);

​				console.log(obj.eat);

​			

//点语法和[]谁好

//一般咱们使用的时候都使用的是点语法，但是在某些特定场合下我们点语法没法用

​			//此时我们还得用[]语法

​			//1、属性名如果不符合标识符规则  点语法无法操作；

//			console.log(obj.con-type);//不能使用点语法

​			console.log(obj['con-type']);//只能使用中括号语法

​			

​			//2、如果我们操作的属性存储在一个变量当中，想用这个变量的值作为属性去操作

​			var a = 'gender';

//			obj.a = 'female';//它添加的属性是a  属性值是'female'

​			obj[a] = 'female';//第一步：先从a变量当中取除a的值，并且自动转化字符串

​						  //第二步：再以转化好的这个字符串为属性，去操作对象

​							  

​			var b = true;

​			obj[b] = 'haha';

​			console.log(obj);				  

​							  

​							  

​			var c = 12.345;

​			obj['c'] = 'heihei';    //obj['c'] ====== obj.c

​			console.log(obj);

​							  

​			//对象的遍历：

​			//数组的遍历使用for循环遍历

​			//对象的遍历使用for in循环去遍历,for in遍历的是对象的属性

​			for(var key in obj){

​				console.log(key,obj[key]);

​			}

​		//数组是数组，数组也是对象(特殊的对象，因为有序)

​			var arr = [1,2,3];

​			arr.heihei = 'hehe';//把数组当对象使用

​			//这是一个对象，里面有数字属性还有其它属性，数字属性对应的部分我们可以认为是数组

​			//其它的属性我们可以认为是对象的属性

​			//for循环遍历数组的时候，只不过是再遍历这个对象数字属性的值而已

​			//for in循环遍历数组的时候，不管数字属性和非数字属性都能拿到（length除外，length默认不能遍历）

​			

​			for(var i = 0; i < arr.length; i++){

​				console.log(arr[i]);//数组当数组去遍历的时候，用for，拿的就是数字属性（下标）的值

​			}

​			

​			for(var key in arr){

​				console.log(key,arr[key]);//数组当对象去遍历的时候，用for。。in 拿的是所有的属性和值

​			}

​			

​			//函数是函数，函数也是对象(特殊的对象，因为可以执行)

​			

​			function fn(){

​				console.log(111);

​			}

​			console.log(fn);//把函数当函数数据去打印，只能打印到函数表面数据	

​			console.dir(fn);//把函数当对象数据去打印，能打印函数内部存储的数据

​			

​			

//			函数当函数用  加括号 

​			fn()//函数当函数用  加括号 ,当函数去用是再执行函数表面的数据代码

​			fn.a = 100;//函数当对象用 ，给函数对象内部添加属性为a 值为100

​			

​			console.log(fn);//把函数当函数数据去打印，只能打印到函数表面数据	

​			console.dir(fn);

**day08**

**this讲解**

**函数和方法要分清**

​			//函数就是我们一般在外面写的函数，方法是对象内部的一个属性

/			/1、普通函数调用的时候this  window

​			//2、方法当中调用 this 这个方法的对象

​			//3、构造函数调用的时候 this  准备实例化的对象

​			//4、事件的回调函数，this指的就是事件源

​			//5、call和apply 方法  this可以自己指定

​			// 普通函数和构造函数的区别

​			//调用的时候才知道是普通函数还是构造函数

​			//this不同   返回值不同

​			

**自定义函数创建的实例化对象**

无论是普通函数还构造函数本质上都是函数

​			//只是调用的方式不同，我们把它们的叫法不一样

​			//普通函数和构造函数是在调用的时候才清楚的，而不是定义的时候

​			//函数有两种角色  一种是函数  一种是对象

​			//函数在函数的角色上，又可以多种方式去调用

function Person(name,age,gender){ 			this.name = name;//p1.name = 'zhaoliying' 			this.age = age; 			this.gender = gender; 			this.eat = function(){ 				console.log('吃饭'); 			} 			return [1,2,3]; 		}   //称作普通函数调用 		//this:this指向了window,相当于往window对象上添加属性和属性值 		//返回值：看return，没有return就是undefined,有return就是return的值 		var result = Person('qiwei',40,'female'); 		console.log(result)      //称为构造函数调用 		//this:this代表准备实例化出来的实例化对象，相当于往实例化对象身上添加属性和属性值 		//返回值：1、如果没有return或者return的是一个基本数据，那么都默认返回实例化的对象 		//       2、如果有return，return的是一个对象数据了，那么返回的就是这个对象数据，而 		//       不再是你的实例化对象 		var p1 = new Person('赵丽颖',33,'female'); 

**new干了什么**

//调用的时候new干了4件事

​			//1、首先会在堆当中开辟一个新的空间（准备实例化出来的对象）

​			//2、把函数调用的this指向指向新开辟的空间

​			//3、老老实实执行函数里面的代码，就是把相应的属性和值塞到新的空间当中（实例化过程）

​			//4、把实例化的丰满的有内容的这个空间地址给返回

function Car(name,color,price){ 			this.name = name; 			this.color = color; 			this.price = price; 			this.run = function(){ 				console.log('pao'); 			} 		} 		 //			Car('pasate','black',150000); 		 		 		var c1 = new Car('劳斯莱斯','red',15000000); 

**原型和原型链**

function BeautyGirl(name,age,gender){ 			this.name = name; 			this.age = age; 			this.gender = gender; //				this..eat = function(){ //				console.log('吃饭'); //			} 	} 把所有对象公共的方法，添加到原型对象当中，实现资源共享，节约内存； //			BeautyGirl.prototype.eat = function(){ //				console.log('吃饭'); //			} var g1 = new BeautyGirl('zhaoliying',33,'female'); var g2 = new BeautyGirl('yangmi',34,'female');    g1.eat();    g2.eat();			 console.dir(BeautyGirl); g1和g2调用的eat都是自己独立的eat方法,有自己的独立空间 //         	而最后无论是调用谁的eat方法，效果和结论都是一样的吃饭 //			这样就造成了不必要的空间浪费  内存浪费 		//想想如何能让他们调用方法的时候调用同一份数据就可以，没必要每个人都来一份 		//原型就是来解决这个事情 		//原型又叫原型对象 		//原型对象就是 函数对象身上的一个属性prototype 		//我们把函数对象身上的一个属性prototype 称作是显示原型对象 		//因为我们在修改原型对象数据的时候都是通过prototype去修改的 		 		//不要在每个人身上都添加一样的方法，直接把方法添加在原型对象当中 		 

**call和apply的使用方法**

它们可以修改函数执行时候的this指向，可以修改函数的执行者

//call和apply 作用 修改函数或者方法内部this指向，修改执行者

​			//通常用来让一个对象借用另外一个对象的方法去使用

​			//call和appy区别

​			//1、如果函数或者方法有参数，apply需要把参数放在数组当中

​			//2、如果函数或者方法有参数，call从第二个参数开始用逗号隔开就行

​			

​			//call和apply在借用方法的时候都干了两件事情

​			//1、调用函数或者方法的时候，临时把内部的this修改为自己指定的对象

​			//2、函数或者方法，会自动执行

​			

​			//apply用的很少，call用的比较多

//bind 方法  和 call以及apply很像

​			//它也是可以修改原来的函数或者方法的内部this指向

​			//只不过它会返回一个新的函数，而且要调用必须手动调用

​			//永久的把别人的东西拿走

//			function fn(){ //				console.log(this); //			} //			 //			var obj = { //				name:'赵丽颖', //				age:33 //			} //			fn();//本来this指向的是window，代表window在调用这个函数 //			//想让obj去调用这个函数 //			fn.call(obj);//调用fn的时候修改fn内部this指向，让obj去调用fn 		 		//修改函数内部的this指向，可以让我们很方便的让一个对象使用另外一个对象的方法 

​	function Dog(name,age){ 			this.name = name; 			this.age = age; 		} 		 		function Car(name,color){ 			this.name = name; 			this.color = color; 		} //			Object.prototype.run = function(){ //				console.log('跑的很快'); //			}//直接把方法放在Object的原型对象当中也行，但是不好 		 		Dog.prototype.run = function(a,b){ 			console.log(a,b); 			console.log(this); 			console.log('跑的很快'); 		} 		 //			Car.prototype.run = function(){ //				console.log('跑的很快'); //			} 		 		var d1 = new Dog('旺财',3); 		d1.run(10,20); 		var c1 = new Car('法拉利','red'); 		 		//让车去借用狗的方法去跑 		//call和apply 可以让我们一个对象去使用另外一个对象的方法（修改方法内部this指向） //			c1.run(); 		d1.run.apply(c1,[100,200]); 		d1.run.call(c1,1000,2000); 		//bind 方法  和 call以及apply很像 		//它也是可以修改原来的函数或者方法的内部this指向 		//只不过它会返回一个新的函数，而且要调用必须手动调用 		//永久的把别人的东西拿走 		var fn = d1.run.bind(c1); 		fn(10000,20000); 

**instanceof**

/instanceof出现可以帮我们解决判定死数组和对象

​			//instanceof是用来判断一个对象是否是一个构造函数的实例：

​			// A instanceof B     A必须是一个对象    B必须是一个构造函数

//数组判定 		var b = []; 		var c = {}; 		var d = function(){}; 		console.log(b instanceof Array);//看b里面的数据是否是Array的实例 		console.log(c instanceof Array); 

//对象判定 		//一切皆对象（除了基本数据值）也就是说所有的对象类型数据  都是Object的实例 		console.log(b instanceof Object);//看b里面的数据是否是Array的实例 		console.log(c instanceof Object); 		console.log(Array instanceof Object); 		console.log(d instanceof Object); 		console.log(Object instanceof Object); 		console.log(1 instanceof Object);//false 

//=== 可以判定undefined和null 		//因为他们是类型 他们也只有一个值； 		var e = null; 		console.log(e === null); 

**day09**

**JSON**

是js内置的对象，就是别人给你已经创建好的一个对象，直接拿来用

json是一种数据格式

​			//用来让前后端进行数据交互的统一格式

​			//前端往后端去传输数据的时候必须转化为json格式,json本质上是一个字符串，叫做json串

//前端往后台传递 //1、先把数据封装为一个对象 var obj = {    username:'aaa',    age:33 } var result = JSON.stringify(obj); //后台往前端传，传递过来的也一定是json串，我们需要从json串当中获取我们需要的数据 //先把json串转化为前端的对象 var result1 = JSON.parse(result);		 

**内置Math对象**

var num = 1.63;

Math.**floor**(num);//向下取整

Math.ceil(num);//向上取整

Math.round(num);//四舍五入取整

Math.max(26,18,33,6);//求出一系列数字当中的最大值

Math.min(26,18,33,6);//求出一系列数字当中的最小值

Math.PI;//圆周率

Math.pow(2,5);//求2的5次方

Math.abs(-100);//绝对值

js当中求一个角度的三角函数，不能写角度，必须把角度转化为弧度

​			//圆的周长除以半径   代表360度所对应的弧度   2*PI

​			//180度 -----> PI

​			//30度 ----->？

//			180/PI = 30/?     30*PI / 180

console.log(Math.sin(30*Math.PI / 180));//求30度对应的正弦值

Math.random( );//取的是0-1之间的随机数，包含0但是不包含1

求 a - b 之间的随机整数(Math.floor(Math.random()*(**b - a + 1) + a**);

**随机验证码**

var str = '1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'; var code = ''; for(var i = 0; i < 8; i++){    code += str[Math.floor(Math.random()*str.length)]; } console.log(code); 

**内置Date日期时间对象**

// Date是一个函数

 不管使用普通调用还是构造函数调用，最后都会返回一个日期时间对象

一般我们都是要去获取对象当中的年月日时分秒  去自己格式化日期和时间用的

var date = new Date();//

​			console.log(date);

​			console.log(date.getFullYear());//拿年

​			console.log(date.getMonth());//拿月份  但是月份是0 - 11表示的，求出来记得+1

​			console.log(date.getDate());//拿日

​			console.log(date.getHours());//时

​			console.log(date.getMinutes());//分

​			console.log(date.getSeconds());//秒

​			console.log(date.toLocaleTimeString());//获取转化为本地的时间字符串

​			console.log(date.toLocaleDateString());//获取本质的日期字符串

​			console.log(date.getTime());//1970 年 1 月 1 日之间的毫秒数

​			console.log(Date.now());//1970 年 1 月 1 日之间的毫秒数

​			//实例化对象的方法和构造函数对象的方法 各自各自，不能互相混用

​			//原型对象的方法是给实例化对象用的，而不是给构造函数用的

​	//返回一个日期时间字符串  要求日期2020年4月29日	   	function getFormatString(){ 			//格式化当前日期时间 			var date = new Date(); 			var year = date.getFullYear();//拿年 			var month = date.getMonth()+1;//拿月份  但是月份是0 - 11表示的，求出来记得+1 			var day = date.getDate();//拿日 			var time = date.toLocaleTimeString(); 			return '现在是：'+year + '年' + month + '月' + day + '日  ' + time; 		} 		 		console.log(getFormatString()); 

**包装对象**

包装对象就三种

​	//  A.B   A一定是对象    B一定是对象的属性 

​                    var a = 100;                    console.log(a); 		console.log(a instanceof Object); 		console.log(a.toString()); 		console.log(a instanceof Object);   //包装对象就三种 		//Number   String   Boolean 		//我们以后是不会手动去创建包装对象 		var b = new Number(100); 		console.log(b)//这是一个数字的包装对象 		 

​			//a是一个数字，数字是基本数据类型，无法调用方法

​			//1、当用基本数据去调用方法的时候，首先会自动转化为对应包装对象

​			//   a = new Number(a);

​			//2、调用包装对象的方式实现转化字符串

​			//3、当调用完成一瞬间，再把a转化回去原来的数子 a = 100;

**字符串方法**

var str = '1*234567sadh890123A';

//			console.log(str.indexOf('2',3));

​			//功能：从字符串当中查找指定的子串，默认从左往右依次查找，查找到第一次就停止

​			//参数：可以写两个，后面一个可以省略。第一个参数代表指定的子串，第二个参数代表从哪（下标）开始查。

​			//返回值：返回查找到的子串所在的下标，找不到返回-1

​			

//			console.log(str.split(''));

​			//功能：以指定的字符为切割点，将字符串切割为数组返回

​			//参数：指定的切割子串，也可以不写

​			//返回值：返回切割好的数组，如果不传，那么整体字符串会作为数组的一个元素

​			//如果传的是空串，那么每个字符都会作为数组的元素

​			

//			console.log(str.slice(3,7));//以下三个都是截取字符串，记这个*********************

​			//功能：截取指定位置的子串

​			//参数：起始位置和结束位置，包含起始的位置的，但是不包含结束位置的，参数可以是负数

​			//起始位置，必须在结束位置的左侧。第二个参数不写，那么就从起始位置到结束

​			//返回值：返回截取的子串

​			

//			console.log(str.substr(0,4));

​			//功能：截取指定长度的子串

​			//参数：起始位置和截取长度，包含起始的位置的。位置可以是负数

​			//第二个参数不写，那么就从起始位置到结束

​			//返回值：返回截取的子串

//			console.log(str.substring(4,0));

//			//功能：截取指定位置的子串

//			//参数：起始位置和结束位置不确定，首先比较两个参数的大小之后，决定起始位置和结束位置     参数不能写负数

//			//第二个参数不写，那么就从起始位置到结束

//			//返回值：返回截取的子串

//			console.log(str.toLowerCase());//*************

​			//功能：把字符串转化为小写

//			//参数：无

//			//返回值：返回转化为小写的字符串，新的字符串

//			console.log(str.toUpperCase());//**********

//			//功能：把字符串转化为大写

//			//参数：无

//			//返回值：返回转化为大写的字符串，新的字符串

//			

//			console.log(str.valueOf());//获取字符串的基本值，就是自己

//			console.log(str.toString());//把字符串转化为字符串

//			

//			了解：

//			console.log(str.charAt(8));//获取指定位置的字符返回；位置不存在空串  str[8];

//			console.log(str.charCodeAt(9));//获取指定位置的字符转化为Unicode码返回；

//			console.log(str.concat('iii'));//拼接字符串，如果不传参，相当于复制字符串；// +

//			console.log(String.fromCharCode(49));//把一个Unicode码转化为字符

//			console.log(str.lastIndexOf('23'));//求字串位置,默认从末尾开始

//			console.log(str.localeCompare('12345678'));//比较大小0代表相等  1代表原串大 -1代表原串小

//			字符串也可以使用下标进行操作；

**数组的方法**

//一、数组增删改查的方法，必须搞定 一共5个

//			var arr = [1,2,3,4];

//1-1 末尾增删

​			//末尾增

var result = arr.push(100,200,300);

​			//功能：在数组末尾添加元素，可以是多个

​			//参数：指定的要添加的元素

​			//返回：返回添加元素后原数组的长度

​			//这个方法会影响原数组

//末尾删

//			var result = arr.pop();

​			//功能：在数组末尾删除一个元素

​			//参数：无

​			//返回：返回删除的那一个元素

​			//这个方法会影响原数组

//1-2 头部增删

​			//头部增

var result = arr.unshift(100,200,300);

​			//功能：在数组头部添加元素，可以是多个

​			//参数：指定的要添加的元素

​			//返回：返回添加元素后原数组的长度

   //这个方法会影响原数组

//头部删

var result = arr.shift();

​			//功能：在数组头部删除一个元素

  //参数：无

  //返回：返回删除的那一个元素

 //这个方法会影响原数组

1-3 任意位置增删改**splice**

​			//数组增删改一体化

​			//把这个方法当做删除去理解

**arr.splice( 开始位置,删除个数 ,修改的数);**

删：//功能：从任意位置开始删除任意个元素

​	//参数：2个   第一个代表起始位置，第二个代表删除的个数

​	/返回值： 返回删除的元素组成的新数组

​	//会影响原数组

增：  其实就是从某个位置开始删除0个，然后添加新的

​			//功能：从任意位置开始删除0个元素，然后再这个位置添加新的元素

​			//参数：多个   第一个代表起始位置，第二个代表删除的个数固定是0，后面参数的都是新添加的元素

​			//返回值： 返回删除的元素组成的新数组固定就是[]

​			//会影响原数组

改：  其实就是从某个位置开始删除要改的个数，然后添加新的

​			//功能：从任意位置开始删除要改的个数的元素，然后再这个位置添加新的元素

​			//参数：多个   第一个代表起始位置，第二个代表删除的个数，后面参数的都是新添加的元素

​			//返回值： 返回删除的元素组成的新数组

​			//会影响原数组

二、数组排序sort

​			//功能：对数组进行排序

​			//参数：如果不写，那么默认会把数组当中元素转化为字符串，进行排序

​			//正常排序，必须传递一个函数，这个函数的返回值决定是升序还是降序

​			//返回值：返回拍好序的原数组

var arr = [10,6,2,20]; //			var result = arr.sort(function(a,b){ ////				return a - b;//升序 //				return b - a;//降序 //			}); 

三、数组转化字符串  join

​			//功能：以指定的连接符，降数组中的元素 连接成一个字符串

​			//参数：如果不写，默认以逗号连接， 如果是空串，数组元素直接拼接 ，如果是指定的，那连接符就是指定的e

​			//返回值：返回连接到的字符串;

​			//不会影响原数组；

//			var arr = [10,6,2,20];

//			var result = arr.join('');

四、翻转数组 reverse

​			//功能：翻转数组

​			//参数：无

​			//返回值：返回翻转后的原数组;

​			//会影响原数组；

//			var arr = [10,6,2,20];

//			var result = arr.reverse();

五、slice和concat（了解）

​			//slice用法和字符串的slice完全一样

​			//功能：截取数组的元素

​			//参数：起始位置和结束位置，不包含结束位置的，参数可以是负数

​			//返回值：返回截取的元素组成的新数组

​			//不会影响原数组

//			var arr = [10,6,2,20];

//			var result = arr.slice(1);

//			console.log(arr);

//			console.log(result);

​			

​			//concat 往数组内部拼接元素

​			//功能：往数组内部添加元素

​			//参数：要添加的元素，如果不传参，相当于复制了一个数组

​			//返回值：返回添加完元素之后的新数组，原数组不变

​			//不会影响原数组

//			var arr = [10,6,2,20];

//			var result = arr.concat();

//			console.log(arr);

//			console.log(result);

//			console.log(arr == result);//对象数据判等，判的就是地址，地址一样就相等

六、toString

​			//功能：把数组对象转化为基本数据字符串

​			//参数：无

​			//返回值：返回数组转化的字符串

​			

//			var arr = [10,6,2,20];

//			var result = arr.toString();

//			console.log(arr);//'10,6,2,20'

//			console.log(result);

​			

​			//数组   函数  对象  都有toString方法，返回的结果是不一样的

​			//数组调用这个方法，返回的就是去掉[]后剩余的，加引号

​			//函数调用这个方法，返回的就是函数数据本身，加引号

​			//对象调用这个方法，返回的是固定的 '[object Object]'

​			

​			

//			console.log([1,2,3].toString());//'1,2,3'

//			function fn(){};

//			console.log(fn.toString());

//			console.log({name:'zly'}.toString());

​			//两遍都是对象数据   对象数据之间的判等，判的就是地址

​			//所有的对象数据转化布尔值，都是true   

​			//对象和对象之间的比较及运算 以及 对象和基本数据之间的比较判等和运算 都要把对象数据转化为基本数据

​			//然后再按照基本数据的隐式转换去运算；

//		

//			console.log([1,2,3] + [1,2,3]);//

//			console.log(fn - 100);//'function fn(){};'-100

//			console.log({name:'zly'} + 100);

​			

​	**//这些方法也是必须搞定**		

 //			1. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标，不存在返回-1 //			var arr = [1,2,3]; //			var result = arr.indexOf(2); //			console.log(result); 		 		 		//数组去重  第一种方式 //			var arr = [1,2,3,41,1,2,1]; //			var newArr = []; //			var flag = true; //			for(var i = 0; i < arr.length; i++){ //				for(var j = 0; j < newArr.length; j++){ //					if(arr[i] == newArr[j]){ //						flag = false; //						break; //					} //				} //				 //				if(flag){ //					newArr[newArr.length] = arr[i]; //				} //				 //				flag = true; //			} //			console.log(newArr); 		 		//数组去重第二种 //			for(var i = 0; i < arr.length; i++){ //				if(newArr.indexOf(arr[i]) == -1){//拿一个元素就去新数组内去找，如果没有返回-1； //					newArr.push(arr[i]); //				} //			} //			console.log(newArr); 		 //			2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标，不存在返回-1 			//*******************************************8 //			3. Array.prototype.forEach(function(item, index){}) : 遍历数组 //				for循环是最基本的循环,它不是数组的方法 			 //				var arr = [1,2,3,4]; //				arr.forEach(function(item,index){ //					console.log(index,item); //				}) 			 //				数组的forEach方法也可以去遍历数组,但是不能continue和break 			//它比for循环效率要高的多； 			 //			4. Array.prototype.map(function(item, index){}) :  			//遍历数组返回一个新的数组，新的数组和老的数组有关系 //				var arr = [1,2,3]; //				 //				var result = arr.map(function(item,index){ //					return item * 2;  //返回由原数组 计算后的一个新值，放入一个新数组里面 //				}) //				 //				console.log(result); 		 //			5. Array.prototype.filter(function(item, index){}) :  //				遍历过滤出一个新的子数组 			var arr = [10,20,5,7];  			var result = arr.filter(function(item,index){ 				return item >= 6; 			}) 			console.log(result); 			 